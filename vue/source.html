<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>vue源码 | 顽固的博客</title><meta name="description" content="分享学到的">
    <link rel="modulepreload" href="/assets/app.7d96ffc6.js"><link rel="modulepreload" href="/assets/source.html.84cd7bfa.js"><link rel="modulepreload" href="/assets/source.html.a6d76634.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/assets/style.39d5bbe5.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="https://vuejs.org/images/logo.png" alt="顽固的博客"><span class="site-name can-hide">顽固的博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/js/base" class="" aria-label="前端基础"><!--[--><!--]--> 前端基础 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="算法"><span class="title">算法</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="算法"><span class="title">算法</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/js/write" class="" aria-label="手写api"><!--[--><!--]--> 手写api <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/algorithm/base" class="" aria-label="基础算法"><!--[--><!--]--> 基础算法 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/wangux" rel="noopener noreferrer" target="_blank" aria-label="github"><!--[--><!--]--> github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/js/base" class="" aria-label="前端基础"><!--[--><!--]--> 前端基础 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="算法"><span class="title">算法</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="算法"><span class="title">算法</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/js/write" class="" aria-label="手写api"><!--[--><!--]--> 手写api <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/algorithm/base" class="" aria-label="基础算法"><!--[--><!--]--> 基础算法 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/wangux" rel="noopener noreferrer" target="_blank" aria-label="github"><!--[--><!--]--> github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">js <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/js/base" class="sidebar-item" aria-label="js基础"><!--[--><!--]--> js基础 <!--[--><!--]--></a><!----></li><li><a href="/js/var" class="sidebar-item" aria-label="变量、函数声明提升"><!--[--><!--]--> 变量、函数声明提升 <!--[--><!--]--></a><!----></li><li><a href="/js/stack" class="sidebar-item" aria-label="JS执行上下文和执行栈"><!--[--><!--]--> JS执行上下文和执行栈 <!--[--><!--]--></a><!----></li><li><a href="/js/extend" class="sidebar-item" aria-label="继承"><!--[--><!--]--> 继承 <!--[--><!--]--></a><!----></li><li><a href="/js/write" class="sidebar-item" aria-label="基础手写，bind、call、apply等"><!--[--><!--]--> 基础手写，bind、call、apply等 <!--[--><!--]--></a><!----></li><li><a href="/js/async" class="sidebar-item" aria-label="同步与异步，阻塞与非阻塞"><!--[--><!--]--> 同步与异步，阻塞与非阻塞 <!--[--><!--]--></a><!----></li><li><a href="/js/eventloop" class="sidebar-item" aria-label="EventLoop"><!--[--><!--]--> EventLoop <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">ts <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/ts/base" class="sidebar-item" aria-label="ts基础"><!--[--><!--]--> ts基础 <!--[--><!--]--></a><!----></li><li><a href="/ts/advance" class="sidebar-item" aria-label="ts进阶"><!--[--><!--]--> ts进阶 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">vue <span class="down arrow"></span></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/vue/base" class="sidebar-item" aria-label="vue基础"><!--[--><!--]--> vue基础 <!--[--><!--]--></a><!----></li><li><a href="/vue/source" class="router-link-active sidebar-item active" aria-label="vue源码"><!--[--><!--]--> vue源码 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">性能优化 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/performance/base" class="sidebar-item" aria-label="性能优化基础"><!--[--><!--]--> 性能优化基础 <!--[--><!--]--></a><!----></li><li><a href="/performance/sdk1" class="sidebar-item" aria-label="前端埋点、性能分析sdk设计"><!--[--><!--]--> 前端埋点、性能分析sdk设计 <!--[--><!--]--></a><!----></li><li><a href="/performance/sdk2" class="sidebar-item" aria-label="埋点sdk实现"><!--[--><!--]--> 埋点sdk实现 <!--[--><!--]--></a><!----></li><li><a href="/performance/chrome" class="sidebar-item" aria-label="浏览器架构以及渲染流程"><!--[--><!--]--> 浏览器架构以及渲染流程 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">webpack <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/webpack/webpack基础.md" class="sidebar-item" aria-label="webpack基础"><!--[--><!--]--> webpack基础 <!--[--><!--]--></a><!----></li><li><a href="/webpack/webpack原理.md" class="sidebar-item" aria-label="webpack原理"><!--[--><!--]--> webpack原理 <!--[--><!--]--></a><!----></li><li><a href="/webpack/编写Plugin.md" class="sidebar-item" aria-label="编写Plugin"><!--[--><!--]--> 编写Plugin <!--[--><!--]--></a><!----></li><li><a href="/webpack/按需加载.md" class="sidebar-item" aria-label="按需加载"><!--[--><!--]--> 按需加载 <!--[--><!--]--></a><!----></li><li><a href="/webpack/区分环境.md" class="sidebar-item" aria-label="区分环境"><!--[--><!--]--> 区分环境 <!--[--><!--]--></a><!----></li><li><a href="/webpack/使用DllPlugin.md" class="sidebar-item" aria-label="使用DllPlugin"><!--[--><!--]--> 使用DllPlugin <!--[--><!--]--></a><!----></li><li><a href="/webpack/使用ParallelUglifyPlugin多进程压缩代码.md" class="sidebar-item" aria-label="ParallelUglifyPlugin"><!--[--><!--]--> ParallelUglifyPlugin <!--[--><!--]--></a><!----></li><li><a href="/webpack/使用Tree Shaking压缩代码.md" class="sidebar-item" aria-label="Tree shaking"><!--[--><!--]--> Tree shaking <!--[--><!--]--></a><!----></li><li><a href="/webpack/输出分析.md" class="sidebar-item" aria-label="输出分析"><!--[--><!--]--> 输出分析 <!--[--><!--]--></a><!----></li><li><a href="/webpack/缩小文件搜索范围.md" class="sidebar-item" aria-label="缩小文件搜索范围"><!--[--><!--]--> 缩小文件搜索范围 <!--[--><!--]--></a><!----></li><li><a href="/webpack/提取公共代码.md" class="sidebar-item" aria-label="提取公共代码"><!--[--><!--]--> 提取公共代码 <!--[--><!--]--></a><!----></li><li><a href="/webpack/压缩代码.md" class="sidebar-item" aria-label="压缩代码"><!--[--><!--]--> 压缩代码 <!--[--><!--]--></a><!----></li><li><a href="/webpack/happyPack原理.md" class="sidebar-item" aria-label="happyPack原理"><!--[--><!--]--> happyPack原理 <!--[--><!--]--></a><!----></li><li><a href="/webpack/优化文件监听以及浏览器自动刷新.md" class="sidebar-item" aria-label="优化文件监听以及浏览器自动刷新"><!--[--><!--]--> 优化文件监听以及浏览器自动刷新 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">http <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/http/base" class="sidebar-item" aria-label="http基础"><!--[--><!--]--> http基础 <!--[--><!--]--></a><!----></li><li><a href="/http/advance" class="sidebar-item" aria-label="http进阶"><!--[--><!--]--> http进阶 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">前端安全 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/safe/encrypt" class="sidebar-item" aria-label="前端加密安全策略"><!--[--><!--]--> 前端加密安全策略 <!--[--><!--]--></a><!----></li><li><a href="/safe/base" class="sidebar-item" aria-label="前端安全"><!--[--><!--]--> 前端安全 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">前端工程化 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/project/monorepo" class="sidebar-item" aria-label="monorepo"><!--[--><!--]--> monorepo <!--[--><!--]--></a><!----></li><li><a href="/project/jenkins" class="sidebar-item" aria-label="Jenkins安全"><!--[--><!--]--> Jenkins安全 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">算法 <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/algorithm/base" class="sidebar-item" aria-label="基础算法手写"><!--[--><!--]--> 基础算法手写 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="vue源码" tabindex="-1"><a class="header-anchor" href="#vue源码" aria-hidden="true">#</a> vue源码</h1><p>vue的项目目录</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>├─dist                   # 项目构建后的文件
├─scripts                # 与项目构建相关的脚本和配置文件
├─flow                   # flow的类型声明文件
├─packages               # <span class="token function">提供给第三方的包</span><span class="token punctuation">(</span>vue提供出来的<span class="token punctuation">)</span>，例如给服务端渲染、模板渲染（提供给vue<span class="token operator">-</span>loader）等
├─src                    # 项目源代码
│    ├─complier          # 与模板编译相关的代码
│    ├─core              # 通用的、与运行平台无关的运行时代码
│    │  ├─observe        # 实现变化侦测的代码
│    │  ├─vdom           # 实现virtual dom的代码
│    │  ├─instance       # Vue<span class="token punctuation">.</span>js实例的构造函数和原型方法
│    │  ├─global<span class="token operator">-</span>api     # 全局api的代码
│    │  └─components     # 内置组件的代码
│    ├─server            # 与服务端渲染相关的代码
│    ├─platforms         # 特定运行平台的代码，如weex
│    ├─sfc               # 单文件组件的解析代码
│    └─shared            # 项目公用的工具代码
└─test                   # 项目测试代码
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>package 第三方的包<br>template =&gt; 编译成浏览器认识的代码js（通过vue-template-compiler）<br>script 构建源码的脚本和配置文件</p><p>vue运行的时候 对外部的一个表现形式（Runtime运行时），以下都是Runtime：<br>Vnode dom diff dep watcher 响应式数据</p><p>打包生成的vuejs俩种版本Runtime Only和Runtime+Compiler<br>Runtime Only （编译是在离线的时候做的）<br>这个版本只包含运行时的js代码，体积更轻量，在使用该版本的Vue.js时，需要webpack引入vue-loader把.vue文件编译成js。编译后我们得到的是一个with的render函数，render函数生成虚拟DOM。<br>Runtime + compiler（在线编译）<br>该版本包含全功能的Vue(runtime+compiler),体积更大，而且在线编译时的compiler转换js会消耗性能。<br>只有以下情况会用到compiler：（在没有使用webpack的情况可以引入全功能vue）<br>1.有指定template;<br>2.没指定template，也没指定render（这时候使用的就是被挂载元素的outerHtml）。</p><p>compiler生成Ast（抽象语法树），把vue模板编译成with语句，with的render函数生成虚拟DOM<br>（with的作用是能把template中的js语句直接拿过来用，不用编译管this的作用域）<br>vue2为什么要用with？<br>因为编译不了vue模板内（template）的js语句</p><p>模板编译阶段做的事情？<br>运行时版本的$mount方法获取到dom元素后直接进入挂载阶段，而在完整版的$mount方法中是先将模板进行编译，然后再调用运行时版本的$mount方法，进入挂载阶段。完整版的$mount方法是把用户传入的el选项或则template选项中获取到用户传入的内部或则外部模板，然后将获取到的模板编译成render函数，最后调用运行时版本的$mount方法进行挂载。</p><p>src =&gt; 核心源码<br>VNode<br>(html + css) =&gt; 渲染引擎解析（浏览器，webkit/blink） =&gt; 调度解析，生成layer tree paint =&gt; 真实Dom<br>频繁操作真实DOM慢的原因是js获取dom属性，需要俩个线程之间进行交互（一个是webkit也叫渲染引擎另一个是v8）</p><p>js =&gt; v8 =&gt; 执行js<br>babel =&gt; 2M大小（在线编译会下载到浏览器里，需要包含编译vue的js）</p><p>js<br>在线编译 浏览器中把vue编译成浏览器能识别的js语句<br>离线编译 上线前通过webpack、babel进行编译成浏览器能识别的js语句</p><p>双向绑定的核心<br>1.怎么知道别人在使用这个数据<br>2.怎么知道是谁在使用这个数据<br>3.怎么知道存在什么地方<br>4.怎么知道什么时候改了这个数据<br>5.怎么知道这个数据对应的callback使用者是谁</p><p>Watcher 回调以及要做的事情<br>dep 存储 关系 数据 = &gt; watcher<br>Observer 响应式数据 =&gt; 处理数据为可监听<br>deractive 指令</p><p>vue1 一个指令一个watcher(watcher太多dep炸了) 空间<br>vue2 一个组件一个watcher（组件内dom diff） 空间一部分（指的是dep回存储数据映射关系），时间一部分（dom diff）</p><p>react 空间0（从根组件开始遍历） all in 时间（所以react需要时间分片）</p><p>为什么要重写array的双向绑定<br>数组也可以通过Object.defineProperty监听的，但因为性能问题，array在内存中是连续存储的，如果在数组的前面插入数据就会不断触发update（改变array的索引会多次触发Object.defineProperty的set，），引起多次render。</p><p>vue2性能差的原因？<br>小应用其实挺快的，慢的原因是因为需要空间存储watcher和Observer的关系，也就是需要维护的watcher越多，占用空间越大，应用越大越卡。</p><p>1.vue实例化 _init 挂载基本属性，初始化基本api、生命周期等<br>2.$mounted (分为不同平台，使用updateComponent包一层) =&gt; 模板编译 render<br>3.mountComponent =&gt; 整个Vue实例<br>4.构建 updateComponent函数</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code> <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//TAG:绑定render ，</span>
    vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>5.构建一个Watcher<br>new Watcher(vm, updateComponent)<br>-Watcher中触发自己的get方法，当前watcher实例添加到Dep<br>-getter =&gt; 添加依赖到Dep，执行run方法<br>-run =&gt; 执行render生成Vnode</p><p>6.vm.<em>update 接受Vnode<br>7.开始__patch</em>_<br>-首次是挂载<br>-下一次更新（进行Dom diff 生成真实dom）</p><p>vue模板编译是通过正则匹配</p><p>vue编译时优化（dom diff 时可直接跳过静态节点）<br>只能做静态节点优化<br>-判断当前节点是否是静态节点<br>-递归遍历子节点是否都是静态节点，有一个不是，则标记当前节点不是静态节点</p><p>keep-alive LRU算法<br>静态节点标记<br>next-tick</p><p>computed和watch的区别<br>computed是基于响应式依赖进行缓存的，只有在响应式依赖改变的时候，才会重新更新值<br>watch是一个对数据监听的回调，只有依赖的data的数据变化是才会触发回调，回调中传入newVal和oldval，vue会在实例化的时候调用$watch()，会遍历watch对象的每一个属性</p><p>vue.$forceUpdate方法原理？<br>当实例依赖的数据发生变化时（数据的setter里会调用dep.notify()方法通知收集到的每一个watcher实例），变化的数据会通知其收集的依赖列表(watcher数组)里的依赖进行更新（执行watcher的update方法）。<br>根本上就是调用当前实例上watcher实例的update方法重新渲染。</p><p>vue.$nextTick原理<br>vue对DOM的更新策略是再侦听到数据变化时，vue会开启一个事件队列（就是把所有的watcher存到数组中），并在一个宏任务或则微任务中执行所有的数据变更（也就是执行watcher的update方法）。<br>设计的原因:如果同一个watcher被多次触发，每次都要更新，会触发一些没必要的DOM操作，增加性能损耗。</p><p>$nextTick方法会把回调函数放到callbacks中等待执行，然后将执行函数放到宏任务或则微任务中，事件循环到了宏任务或则微任务，执行函数依次执行callbacks中的回调。</p><p>讲一下keep-alive<br>keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM<br>keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们<br>使用场景：可以在路由中meta属性中配置需要缓存的组件，在使用keep-alive时再做判断<br>原理：<br>该组件是一个函数式组件，组件渲染时会执行render函数，在该组件内有一个存储组件对象以及存储组件唯一key的数组，在mounted中监听include和exclude的变化，destory中删除所有的缓存，核心在render中，render中会先取组件的key值，再判断缓存中是否有，如果有直接返回组件实例，同时删除该key并重新放到存储组件key数组末尾（LRU算法，有max时删除最久没有被使用的组件），如果没有则缓存该组件并直接返回Vnode。</p><p>缓存后如何取数据<br>1.可以在activated钩子函数中取（actived服务端渲染不会被调用）<br>2.可以再beforeRouterEnter中取</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><!----></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.7d96ffc6.js" defer></script>
  </body>
</html>
